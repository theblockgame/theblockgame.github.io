<!DOCTYPE html>
<html>
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title> Block game </title>
        <script type = "text/javascript">
const board_width = 10;
const board_height = 20;
const box_size = 22;
const box_space = 2;
const box_size_spaced = box_size + box_space;
const block_size = 5 * box_size_spaced;
const margin_y = 5;
const margin_x = 5;

var blocks = [
    { id: "T", original_shape: [ [-1, -1], [0, -1], [1, -1], [0, 0] ], color: "purple" },
    { id: "I", original_shape: [ [-1, -1], [0, -1], [1, -1], [2, -1] ], color: "cyan" },
    { id: "S", original_shape: [ [-1, 0], [0, 0], [0, -1], [1, -1] ], color: "green" },
    { id: "Z", original_shape: [ [-1, -1], [0, -1], [0, 0], [1, 0] ], color: "red" },
    { id: "O", original_shape: [ [-1, -1], [0, -1], [-1, 0], [0, 0] ], color: "yellow" },
    { id: "L", original_shape: [ [-1, 0], [0, 0], [1, 0], [1, -1] ], color: "brown" },
    { id :"J", original_shape: [ [-1, -1], [-1, 0], [0, 0], [1, 0] ], color: "blue" }
];

const action_keys = { p: 80, space: 32, left: 37, right: 39, up: 38, down: 40, s: 83, w: 87, h: 72, q: 81, r: 82  }
const debug = true;
const refresh_rate = 1000 / 30; // 30 FPS

const quick_game_time = 1000 * 60 * 3; // 3 min

const game = {
    timers: [],
    state: null,
    states: null,
    current_screen: null,
    next_piece: null,
    mem_piece: null,
    is_new_personal_best: null,
    main_loop_timer: null,
    
    init: function() {
        game.states = { menu: {}, not_started: {}, play: {}, paused: {}, game_over: {}, confirm_new_game: {} };
        for (const [id, state] of Object.entries(game.states)) state.id = id;
        game.states.play.handlers = [
            { filter: (e) => [action_keys.p, "pause"].includes(e.key), screen: "pause", action: game.pause, state: game.states.paused },
            { filter: (e) => e.key === action_keys.space, action: game.drop },
            { filter: (e) => e.direction === "swipe_down", action: game.drop },
            { filter: (e) => e.key === action_keys.left, action: function(e) { game.move_left_or_right(-1) }},
            { filter: (e) => e.key === action_keys.right, action: function(e) { game.move_left_or_right(1) }},
            { filter: (e) => e.direction === "move", action: function(e) { game.move_left_or_right(e.value); } },
            { filter: (e) => e.key === action_keys.up, action: game.rotate_cw },
            { filter: (e) => e.direction === "point", action: game.rotate_cw },
            { filter: (e) => e.key === action_keys.down, action: game.rotate_ccw },
            { filter: (e) => [action_keys.h, "hold"].includes(e.key), action: game.hold_piece }
        ];
        if (debug) {
            game.states.play.handlers.push(
                { filter: (e) => { return e.key === action_keys.w; }, action: () => inc("level", 1) });
            game.states.play.handlers.push(
                { filter: (e) => { return e.key === action_keys.s; }, action: () => inc("level", -1) });
        }

        game.states.menu.handlers = [
            { filter: (e) => [action_keys.s, "new_game"].includes(e.key), screen: "play", action: function() { game.restart_new_game(0); }, state: game.states.play },
            { filter: (e) => [action_keys.q, "new_quick_game"].includes(e.key), screen: "play", action: function() { game.restart_new_game(quick_game_time); }, state: game.states.play }
        ];
        game.states.paused.handlers = [
            ...game.states.menu.handlers,
            { filter: (e) => [action_keys.p, action_keys.r, "resume"].includes(e.key), screen: "play", action: game.resume, state: game.states.play }
        ];

        game.states.confirm_new_game.handlers = [
            { filter: (e) => ["key_press", "touch"].includes(e.class), action: game.restart_new_game, state: game.states.play }
        ];
        game.state = game.states.menu;
        msg.log("Initial game state is ", game.state.id);
        this.switch_to_screen("menu");
    },

    switch_to_screen: function(screen) {
        for (const elem of document.querySelectorAll('[data-screen]')) {
            if (elem.id === "board") continue;
            elem.style.visibility = elem.dataset.screen === screen ? "visible" : "hidden";
        }
        this.current_screen = msg.log("Switching to screen ", screen);
    },

    handle_event: function(event) {
        msg.log("State is ", game.state.id);
        const handlers = game.state.handlers;
        if (game.state.handlers) for (const h of game.state.handlers) {
            if (h.filter(event)) {
                if (h.screen) game.switch_to_screen(h.screen);
                if (h.action) h.action(event);
                if (h.state) {
                    msg.log("Entering state ", h.state.id);
                    game.state = h.state;
                }
                return;
            }
        }
        msg.log_json("WARN! None of the handlers matched for ", event);
    },

    start_game: function(game_time = 0) {
        document.getElementById("main").dataset.game_time = game_time;
        msg.refresh_time();
        board.init();
        game.clear_hold_piece();
        msg.send(["3", "2", "1"], "", 500);
        msg.send(["Play!"], "", 1000, () => {
            msg.log("New game");
            score_board.clear_current_stats();
            msg.timer_on();
            const game_time = msg.refresh_time();
            game.timers.push(window.setInterval(msg.refresh_time, 1000));
            if (game_time > 0) game.schedule_count_down(game_time);
            game.is_new_personal_best = false;
            game.next_piece = { ...blocks[Math.floor(Math.random() * blocks.length)] };
            game.create_new_piece();
            game.state = game.states.play;
            game.main_loop_timer = window.setInterval(game.main_loop, refresh_rate);
        }); 
    },

    schedule_count_down: function(remaining) {
        game.timers.push(...msg.count_down([120, 60, 10, 3, 2, 1], remaining, game.timeout));
    },

    restart_new_game: function(game_time = 0) {
        game.state = game.states.not_started;
        window.clearInterval(game.main_loop_timer); game.main_loop_timer = null;
        msg.timer_clear();
        while (game.timers.length > 0) window.clearInterval(game.timers.pop());
        msg.clear_messages();
        piece.remove_shadow();
        game.start_game(game_time);
    },

    pause: function() {
        msg.timer_off();
        while (game.timers.length > 0) window.clearInterval(game.timers.pop());
        msg.log("Pause.");
    },

    resume: function() {
        msg.timer_on();
        const remaining_time = msg.refresh_time();
        game.timers.push(window.setInterval(msg.refresh_time, 1000));
        if (remaining_time > 0) game.schedule_count_down(remaining_time);
        msg.log("Resume.");
    },

    hold_piece: function() {
        if (game.mem_piece) {
            if (board.overlap(game.mem_piece.shape, piece.screen_x, piece.screen_y)) return; // no space
            [ piece.current_piece, game.mem_piece ] = [ game.mem_piece, piece.current_piece ];
            piece.draw_blocks(piece.current_piece, piece.piece_div);
        } else {
            piece.piece_div.parentNode.removeChild(piece.piece_div);
            game.mem_piece = piece.current_piece;
            game.create_new_piece();
        }
        game.mem_piece.shape = game.mem_piece.original_shape; // reset orientation
        piece.draw_piece(game.mem_piece, "mem-piece", -5, 20, 0.8);
        piece.draw_shadow();
    },

    clear_hold_piece: function() {
        if (game.mem_piece) {
            const div = document.getElementById("mem-piece");
            while (div.lastElementChild) div.removeChild(div.lastElementChild);
            game.mem_piece = null;
        }
    },

    create_new_piece: function() {
        const current_piece = this.next_piece;
        this.next_piece = { ...blocks[Math.floor(Math.random() * blocks.length)] };
        piece.draw_piece(this.next_piece, "next-piece", -5, 20, 0.8);  
        return piece.create_new(current_piece);
    },

    game_over: function() {
        msg.timer_off();
        window.clearInterval(this.main_loop_timer); this.main_loop_timer = null;
        while (game.timers.length > 0) window.clearInterval(game.timers.pop());
        this.state = game.states.game_over;
        score_board.update_and_show_current_stats();
        msg.send(["Game Over!"], "", 2000, () => {
            game.state = game.states.menu;
            this.switch_to_screen("menu");
        });
    },

    timeout: function() {
        msg.send(["Timeout!"], "", 1000);
        game.game_over();
    },

    freeze_current_piece: function() {
        board.mark_position_to_board(piece.screen_x, piece.screen_y, piece.current_piece, piece.piece_div);
    },

    clear_full_lines: function(lines) {
        lines.forEach((l) => board.remove_line(l));
        board.animate_drop(lines, 0, box_size_spaced, 4, refresh_rate);
    },

    move_left_or_right: (dx) => piece.move_left_or_right(dx < 0 ? -1 : dx > 0 ? 1 : 0),
    move_left: () => piece.move_left_or_right(-1), 
    move_right: () => piece.move_left_or_right(1), 
    drop: () => piece.drop(),
    rotate_cw: () => piece.rotate(1),
    rotate_ccw: () => piece.rotate(-1),

    main_loop: function() {
        if (game.state != game.states.play) return;
        const blocked = !piece.move_down_at_most(0.4 * Number(get("level")));
        if (blocked) {
            game.freeze_current_piece();
            inc("score", (Number(get("level")) * piece.current_piece.shape.length));
            const lines = board.find_full_lines();
            if (lines.length > 0) {
                inc("score", Math.floor(Math.pow(2, lines.length - 1) * 100));
                inc("lines", lines.length);
                inc("lines_" + lines.length, 1);
                if (lines.length == 4) msg.send(["Nice, 4 rows!"], "", 1000);
                if (Number(get("lines")) / 10 > Number(get("level"))) {
                    inc("level", 1);
                    msg.send(["Level up!"], "", 1000)
                }
                game.clear_full_lines(lines);
            }
            if (Number(get("score")) > score_board.ot_stats.score) {
                if (!game.is_new_personal_best) {
                    if (score_board.ot_stats.score > 0) msg.send(["New personal best!"], "", 2000);
                    game.is_new_personal_best = true;
                }
            }
            const room_for_new_piece = game.create_new_piece();
            if (!room_for_new_piece) game.game_over();
        }
    }
}

const msg = {

    queue: [],
    current_entry: null,

    init: function() {
        window.setInterval(msg.draw_next_message, 100);
    },  

    send: function(messages, type, time, after_action) {
        for (var i = 0; i < messages.length - 1; ++i) {
            this.queue.push({ message: messages[i], type, time });
        }
        const last_entry = { message: messages[i], type, time, after_action };
        msg.queue.push(last_entry);
        return last_entry;
    },

    draw_next_message: function() {
        if (msg.queue.length == 0 || msg.current_entry) return;
        msg.current_entry = msg.queue.shift();
        const div = document.getElementById("message");
        div.className = "message " + msg.current_entry.type;
        div.style.visibility = "visible";
        div.innerText = msg.current_entry.message;
        if (msg.current_entry.time !== 0) setTimeout(msg.clear_message, msg.current_entry.time);
    },

    clear_message: function() {
        const entry = msg.current_entry;
        msg.current_entry = null;  
        if (entry && entry.after_action) entry.after_action();
        const div = document.getElementById("message");
        div.style.visibility = "hidden";
        div.innerText = "";
    },

    clear_messages: function() {
        msg.queue = [];
        msg.clear_message();
    },

    timer_on: function() {
        if (document.getElementById("main").dataset.start_time) return; // already running?!?
        document.getElementById("main").dataset.start_time = Date.now();
    },

    timer_off: function() {
        const ds = document.getElementById("main").dataset;
        if (!ds.start_time) return; // not running?!?
        if (!ds.elapsed_time) ds.elapsed_time = 0;
        ds.elapsed_time = Number(ds.elapsed_time) + Date.now() - Number(ds.start_time);
        ds.start_time = "";
    },

    timer_clear: function() {
        this.timer_off();
        const ds = document.getElementById("main").dataset;
        ds.elapsed_time = ds.start_time = ds.game_time = "";
    },

    refresh_time: function() {
        const ds = document.getElementById("main").dataset;
        var total = 0;
        if (ds.elapsed_time) total = Number(ds.elapsed_time);
        if (ds.start_time) total = total + (Date.now() - Number(ds.start_time));
        var remaining = Number(ds.game_time) - total; 

        document.getElementById("time").innerText = print_duration(total);
        if (ds.game_time && Number(ds.game_time) > 0) {
            document.getElementById("remaining").innerText = "(" + print_duration(remaining) + ")";
        }
        return remaining;
    },

    count_down: function(times, end_time, action) {
        handles = [];
        for (const t of times) {
            if (t * 1000 > end_time) continue;
            handles.push(window.setTimeout(() => msg.send([print_duration(t * 1000) + " left"], "", 900), end_time - (t * 1000) - 1000));
        }
        handles.push(window.setTimeout(action, end_time));
        return handles;
    },

    log: debug ? (msg, v = "") => { console.log(msg + v); return v; } : (msg, v) => v,
    log_json: debug ? (msg, json) => { console.log(msg + JSON.stringify(json)); return json; } : (msg, json) => json
}

print_duration = function(msec) {
    var sec = Math.floor(msec / 1000);
    var min = Math.floor(sec / 60); sec -= (min * 60);
    var hour = Math.floor(min / 60); min -= (hour * 60);
    const h = hour > 0 ? hour + ":" : "";
    const mm = min < 10 ? "0" + min : min;
    const ss = sec < 10 ? "0" + sec : sec;
    return h + mm + ":" + ss;
}

parse_duration = function(str) {
    const arr = str.split(":");
    var time = 0; var i = 0;
    if (arr.length > 2) time += Number(arr[i++]) * 60 * 60;  
    if (arr.length > 1) time += Number(arr[i++]) * 60;
    return (time + Number(arr[i])) * 1000;
}

const score_board = {
    item_name: "stats-1.0",
    //fields: [ "time", "level", "score", "lines", "lines_4", "lines_3", "lines_2", "lines_1" ],
    initial_overall_stats:
        { games: 0, time: 0, first_game: Date.now(), score: 0, level: 0, lines: 0, lines_4: 0},
    ot_stats: null,

    init: function() {
        const str = localStorage.getItem(this.item_name);
        this.ot_stats = str ? JSON.parse(str) : this.initial_overall_stats;
        this.show_overall_stats();
    },

    clear_current_stats: function() {
        for (elem of document.getElementsByClassName("game-value")) {
            elem.innerText = elem.dataset.default ? elem.dataset.default : "0";
        }
    },

    update_and_show_current_stats: function(stats = {}) {
        for (elem of document.getElementsByClassName("game-value")) {
            stats[elem.id] = elem.innerText;
        }
        msg.log_json("Stats ", stats);
        for (key of Object.keys(stats)) set("previous-" + key, stats[key]); // show current
        score_board.update_overall_stats(stats); // show overall
    },

    update_overall_stats: function(stats) {
        const ot = this.ot_stats;
        ot.games += 1;
        if (Number(stats.score) > ot.score) ot.score = Number(stats.score);
        if (Number(stats.level) > ot.level) ot.level = Number(stats.level);
        ot.lines += Number(stats.lines);
        ot.lines_4 += Number(stats.lines_4);
        ot.time += parse_duration(stats.time);
        localStorage.setItem(this.item_name, msg.log("Overall stats: ", JSON.stringify(ot)));
        this.show_overall_stats();
    },

    show_overall_stats: function() {
        const ot = { ...this.ot_stats };
        // format some fields
        ot.first_game = Math.floor((Date.now() - ot.first_game) / 1000 / 60 / 60 / 24) + " days ago";
        ot.time = print_duration(ot.time);
        ot.lines = Math.floor(ot.lines / ot.games);
        ot.lines_4 = Math.floor(ot.lines_4 / ot.games);

        set("best", ot.score);
        for (key of Object.keys(ot)) set("ot-" + key, ot[key]);        
    }
}

const board = {

    matrix: [],
    board_div: null,

    init: function() {
        this.board_div = document.getElementById("board");
        this.board_div.innerHTML = "";
        this.board_div.style.width = (box_size_spaced * board_width) + "px";
        this.board_div.style.height = (box_size_spaced * board_height) + "px";

        for (div of document.getElementsByClassName("board-size")) {
            div.style.top = this.board_div.offsetTop + "px";
            div.style.left = this.board_div.offsetLeft + "px";
            div.style.width = this.board_div.offsetWidth + "px";
            div.style.height = this.board_div.offsetHeight + "px";            
        }

        // 1 col outside left and 1 col outside right 
        for (var i = 0; i < board_width + 2; ++i) {
            this.matrix[i] = [];
            var val = 0;
            if (i == 0 || i == board_width + 1) val = 1; // left and right borders
            var j = 0;
            // 4 rows above screen and 1 below screen
            for (j = 0; j < board_height + 3; ++j) {
                this.matrix[i][j] = val;
            }
            this.matrix[i][j] = 1; // bottom border
        }

    },

    find_full_lines: function() {
        var full_lines = [];
        for (var y = 4; y < this.matrix[0].length - 1; ++y) {
            var full = true;
            for (var x = 1; x < this.matrix.length - 1; ++x) {
                if (this.matrix[x][y] == 0) { full = false; break }
            }
            if (full) full_lines.push(y);
        }   
        return full_lines;
    },

    remove_line: function(y) {
        for (var x = 1; x < this.matrix.length - 1; ++x) {
            var box_div = this.matrix[x][y];
            box_div.parentElement.removeChild(box_div);
            this.matrix[x][y] = 0;
        }
    },

    drop_above: function(y) {
        for (var x = 1; x < this.matrix.length - 1; ++x) {
            for (var yy = y - 1; yy > 0; --yy) {
                var box2 = this.matrix[x][yy];
                this.matrix[x][yy + 1] = box2;
            }
        }
    },

    animate_drop: function(lines, current, total, step, delay) {
        lines.forEach((y) => {
            for (var x = 1; x < this.matrix.length - 1; ++x) {
                for (var yy = y - 1; yy > 0; --yy) {
                    var box2 = this.matrix[x][yy];
                    if (box2.my_props) {
                        box2.my_props.top += step;
                        box2.style.top = box2.my_props.top + "px";
                    }   
                }
            }
            piece.drop_shadow(step);
        });
        current += step;
        if (current < total) {
            setTimeout(() => board.animate_drop(lines, current, total, step, delay), delay);
        } else {
            lines.forEach((y) => board.drop_above(y));
            piece.draw_shadow();
        }

    },

    position_in_matrix: function(x, y) {
        return [ Math.floor(x / box_size_spaced) + 1, Math.floor(y / box_size_spaced) + 4 ];
    },

    overlap: function(shape, screen_x, screen_y) {
        const pos = this.position_in_matrix(screen_x, screen_y);
        for (i = 0; i < shape.length; ++i) {
            const x = pos[0] + shape[i][0] + 2;
            const y = pos[1] + shape[i][1] + 2;
            if (x < 0 || x >= this.matrix.length || y < 0 || y >= this.matrix[x].length) continue; 
            if (this.matrix[x][y] != 0) return true;
        }
        return false;
    },

    mark_position_to_board: function(screen_x, screen_y, current_piece, piece_div) {
        const position = this.position_in_matrix(screen_x, screen_y);
        for (i = 0; i < current_piece.shape.length; ++i) {
            const x = position[0] + current_piece.shape[i][0] + 2;
            const y = position[1] + current_piece.shape[i][1] + 2;
            this.matrix[x][y] = piece_div.children[i];
        }
    }
}

const piece = {
    piece_div: null,
    screen_x: null,
    screen_y: null,
    current_piece: null,

    create_new: function(piece) {
        this.piece_div = document.createElement( "div" );
        this.piece_div.className = "piece";
        this.current_piece = piece;
        this.screen_x = ((board_width / 2) - 3) * box_size_spaced;
        this.screen_y = -1 * box_size_spaced;
        if (!piece.shape) piece.shape = piece.original_shape;
        // prevent overlapping on screen in case half of the piece would be visible
        const has_room = !board.overlap(this.current_piece.shape, this.screen_x, this.screen_y - 1)
        const has_room2 = !board.overlap(this.current_piece.shape, this.screen_x, this.screen_y)
        if (has_room) {
            document.getElementById("board").appendChild( this.piece_div );
            this.draw_blocks(this.current_piece, this.piece_div);
            this.move_and_draw(0, 0);
            this.draw_shadow();
        }
        return has_room2;
    },

    draw_piece: function(current_piece, div_id, left = 0, top = 0, scale = 1.0) {
        const div = document.getElementById(div_id);
        const ll = div.parentNode.offsetLeft + left;
        const tt = div.parentNode.offsetTop + top;
        piece.draw_blocks(current_piece, div, ll, tt, scale);
        div.style.left = ll + "px";
        div.style.top = tt + "px";
    },

    draw_blocks: function(piece, piece_div, left = 0, top = 0, scale = 1.0) {
        while (piece_div.lastElementChild) {
            piece_div.removeChild(piece_div.lastElementChild);
        }
        const block_s = Math.floor(scale * block_size);
        const box_s = Math.floor(scale * box_size);
        const box_spaced = Math.floor(scale * box_size_spaced);

        var i = 0;
        if (!piece.shape) piece.shape = piece.original_shape;
        piece.shape.forEach(b => {
            const box = document.createElement("div");
            box.className = "box " + piece.id;
            box.style.width = box_s + "px";
            box.style.height = box_s + "px";
            box.my_props = {};
            box.my_props.left = ((block_s / 2) - (box_spaced / 2) + (box_spaced * b[0])) + left;
            box.my_props.top = ((block_s / 2) - (box_spaced / 2) + (box_spaced * b[1])) + top;
            box.style.left = box.my_props.left + "px";
            box.style.top = box.my_props.top + "px";
            piece_div.appendChild(box);
        });
    },

    rotate: function(direction) {
        var rotated;
        if (direction === -1) {
            rotated = this.current_piece.shape.map( b => [b[1], -1 * b[0]]);
        } else {
            rotated = this.current_piece.shape.map( b => [-1 * b[1], b[0]]);
        }

        // try first on current pos, then 1 right, 2 right, .., 1 left, 2 left, ...
        var can_rotate = false;
        const tries = [ 0, 1, -1, 2, -2 ];
        for (var i = 0; i < tries.length; ++i) {
            var x = this.screen_x;
            if (tries[i] != 0) this.move_left_or_right(tries[i]);
            if (!board.overlap(rotated, this.screen_x, this.screen_y)) {
                can_rotate = true; break;
            }
            if (tries[i] != 0) this.move_and_draw(x - this.screen_x, 0); // cancel move
        }
        if (can_rotate) {
            this.current_piece.shape = rotated;
            this.draw_blocks(this.current_piece, this.piece_div);
            this.draw_shadow();
        }
    },

    can_move: function(dx, dy) {
        const cur_pos = board.position_in_matrix(this.screen_x, this.screen_y);
        const new_pos = board.position_in_matrix(this.screen_x + dx, this.screen_y + dy);
        if (new_pos[0] != cur_pos[0] || new_pos[1] != cur_pos[1]) {
            return !board.overlap(this.current_piece.shape, this.screen_x + dx, this.screen_y + dy);
        }
        return true; // not moved enough, no point checking overlap
    },

    move_and_draw: function(dx, dy) {
        this.screen_x += dx;
        this.screen_y += dy;
        this.piece_div.style.width = block_size + "px";
        this.piece_div.style.height = block_size + "px";
        this.piece_div.style.top = Math.floor(board.board_div.offsetTop + this.screen_y + margin_y) + "px";
        this.piece_div.style.left = (board.board_div.offsetLeft + this.screen_x + margin_x) + "px";
    },

    move_left_or_right: function(dx) {
        if (this.can_move(dx * box_size_spaced, 0)) {
            this.move_and_draw(dx * box_size_spaced, 0);
            this.draw_shadow();
        }
    },

    move_down_at_most: function(dy) {
        if (this.can_move(0, dy)) {
            this.move_and_draw(0, dy);
            return true;
        } else {
            // try with remaining portion
            dy = box_size_spaced - ((this.screen_y + (4 * box_size_spaced)) % box_size_spaced) - 1;
            if (dy < 1) { piece.remove_shadow(); return false; }
            if (this.can_move(0, dy)) {
                this.move_and_draw(0, dy);
                return true;
            }
        }
        piece.remove_shadow();
        return false;
    },

    shadow_div: null,

    draw_shadow: function() {
        if (!this.shadow_div) {
            this.shadow_div = document.createElement( "div" );
            this.shadow_div.className = "piece shadow";
            this.shadow_div.style.width = block_size + "px";
            this.shadow_div.style.height = block_size + "px";
            document.getElementById("board").appendChild( this.shadow_div );
        }
        var dy = box_size_spaced; var step = box_size_spaced;
        while (true) {
            if (board.overlap(this.current_piece.shape, this.screen_x, this.screen_y + dy)) {
                dy -= step;
                step = step / 2;
                if (step <= 1) break;
            }
            dy += step;
        }
        if (dy < (2 * box_size_spaced)) { this.remove_shadow(); return } // too close
        this.shadow_div.style.top = Math.floor(board.board_div.offsetTop + this.screen_y + margin_y + dy) + "px";
        this.shadow_div.style.left = (board.board_div.offsetLeft + this.screen_x + margin_x) + "px";
        this.draw_blocks(this.current_piece, this.shadow_div);
    },

    drop_shadow: function(dy) {
        if (!this.shadow_div) return;
        this.shadow_div.style.top = (this.shadow_div.offsetTop + dy) + "px";
    },

    remove_shadow: function() {
        if (!this.shadow_div) return;
        this.shadow_div.parentElement.removeChild(this.shadow_div);
        this.shadow_div = null;
    },

    drop: function() {
        this.remove_shadow();
        while (piece.move_down_at_most(box_size_spaced)) {
        }
    }
}

// helpers to access values shown on page
const set = function(id, value) { if (document.getElementById(id)) document.getElementById(id).innerText = value; }
const inc = function(id, value) { set(id, Number(get(id)) + value); }
const get = function(id) { return document.getElementById(id) ? document.getElementById(id).innerText : null; }

const init_page = function() {
    score_board.init();
    game.init();
    board.init();
    msg.init();

    const press = function(pressed) {
        msg.log("Key press ", pressed.keyCode);
        if (Object.values(action_keys).indexOf(pressed.keyCode) < 0) return;
        pressed.preventDefault();
        game.handle_event({ class: "key_press", key: pressed.keyCode });
    }
    document.addEventListener( "keydown", press, false );

    const touch_start = function(e) {
        if (mouse_pressed) return;
        msg.log("Touch start ", e);
        const { touches } = e;
        if (touches && touches.length == 1) {
            mouse_pressed = true;
            mouse_x = touches[0].clientX;
            mouse_y = touches[0].clientY;
            move = false;
            drop = false;
            e.preventDefault();
        }
    }
    const swipe_limit = 20;
    const touch_move = function(e) {
        if (!mouse_pressed) return;
        msg.log("Touch move ", e);
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        if (!drop && !move && mouse_y < y - swipe_limit) {
            game.handle_event({ class: "touch", direction: "swipe_down" });
            drop = true; // prevent rotate if drop
            e.preventDefault();
            return;
        }
        if (!drop && Math.abs(x - mouse_x) > swipe_limit) { 
            game.handle_event({ class: "touch", direction: "move", value: x - mouse_x });
            mouse_x = x;
            move = true; // prevent other mouse actions if moving left/right
            e.preventDefault();
        }
    }
    const touch_end = function(e) {
        msg.log("Touch end ", e);
        if (!move && !drop) {
            game.handle_event({ class:"touch", direction:"point"});
            e.preventDefault();
        }
        mouse_pressed = false;
        mouse_y = null;
        mouse_x = null;
        move = false;
        drop = false;

    }
    mouse_pressed = false;
    mouse_x = null;
    mouse_y = null;
    move = false; drop = false;

    const board_div = document.getElementById("touch-area");
    board_div.addEventListener('touchstart', touch_start, { passive: false });
    board_div.addEventListener('touchmove', touch_move, { passive: false });
    board_div.addEventListener('touchend', touch_end, { passive: false });
   
    window.scrollTo(0, 1);
}
        </script>
        <style>
body {
    width: 100%;
    height: 100%;
    margin: 0;
    background-color: rgb(153, 157, 144);
    font-family: 'Courier New', Courier, monospace;
    font-size: small;
}

a {
    color:white;
}

.stats {
    padding: 10px;
    margin-left: 20px;
}

.bg {
    background-color: rgb(153, 157, 144);
    color: black;
}

.container {
    padding: 10px;
    clear: both;
    max-width: 400px;
}

#header {
    background-color: grey;
    text-align: right;
    color: white;
    padding: 5px;
}

#footer {
    background-color: grey;
    text-align: center;
    color: white;
    padding: 10px;
}

#board {
    margin: 5px 0px 0px 0px;
    padding: 5px;
    text-align: center;
    float: left;
}

.score-board {
    padding: 0px 4px 4px 4px;
    text-align: center;
    float: left;
}

.score-board-vertical {
    width: 95%;
    padding: 4px 4px 0px 4px;
}

.score-board-vertical .infoline {
    float: left;
}

.score-table .left {
    text-align: right;
}

.score-table-right {
    width: 20px;
}

.infoline {
    width: 80px;
    float: initial;
    margin: 4px;
    padding: 4px;
    border-radius: 2px;
}

.wide {
    width: 140px;
}


.next {
    height: 80px;
}

.mem {
    height: 120px;
}

.piece {
    z-index: 50;
    background-color: transparent;
    position: absolute;
}

.T { background-color: purple; }
.I { background-color: cyan; }
.O { background-color: yellow; }
.S { background-color: green; }
.Z { background-color: red; }
.L { background-color: brown; }
.J { background-color: blue; }

.shadow {
    z-index: 10;
}

.shadow .box {
    background-color: black;
    border: 1px solid white;
}

.box {
    position: absolute;
    border-radius: 2px;
}

.button {
    border-radius: 4px;
    padding: 5px;
    background-color: green;
    border: 2px solid darkgreen;
    color: white;
}

.message {
    z-index: 97;
    visibility: hidden;
    background-color: transparent;
    color: white;
    font-weight: bolder;
    font-size: larger;
    position: absolute;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
}

#touch-area {
    z-index: 98;
    background-color: transparent;
    position: absolute;
}

.menu {
    z-index: 99;
    position: absolute;
    background-color: rgba(30, 30, 30, 0.7);
    top: 100px;
    vertical-align: center;
    text-align: center;
    width: 300px;
    height: 300px;
}

.menu .title {
    color: white;
    margin: 50px 10px 50px 10px;
}

.menu .button {
    margin: 10px 30px 10px 30px;
}

.black {
    background-color: rgb(30, 30, 30);
    color: white;
}

#remaining-container {
    visibility: hidden;
}
        </style>
    </head>
    <body onload="init_page()">
        <div id="main">
            <div id="menu-div" data-screen="menu" class="menu board-size">
                <div class="title">Block Game</div>
                <br/><br/>
                <div class="button" onclick="game.handle_event({class:'button', key:'new_game'})">New Standard Game</div>
                <div class="button" onclick="game.handle_event({class:'button', key:'new_quick_game'})">New Quick Game</div>o
            </div>
            <div id="pause-div" data-screen="pause" class="menu board-size">
                <div class="title">Paused</div>
                <div class="button" onclick="game.handle_event({class:'button', key:'resume'})">Resume</div>
                <br/><br/>
                <div class="button" onclick="game.handle_event({class:'button', key:'new_game'})">New Standard Game</div>
                <div class="button" onclick="game.handle_event({class:'button', key:'new_quick_game'})">New Quick Game</div>
            </div>
            <div id="touch-area" class="board-size"></div>
            <div id="message" class="message black board-size"></div>
            <div class="score-board score-board-vertical">
                <div class="infoline black">Score:<br/> <span id="score" class="game-value">0</span></div>
                <div class="infoline black wide">Time:<br/>
                    <span id="time" data-default="00:00" class="game-value">00:00</span>
                    <span id="remaining" data-default=" " class="game-value"></span>
                </div>
                <div class="infoline black right">Best:<br/> <span id="best">0</span></div>
            </div>
            <div class="score-board">
                <div class="infoline black">Level:<br/> <span id="level" data-default="1" class="game-value">0</span></div>
                <div class="infoline next black">Next piece:<br/> <span id="next-piece"></span></div>
                <div class="infoline black">
                    <table class="score-table"><tbody>  
                        <tr><td>Lines:</td> <td id="lines" class="game-value">0</td></tr>
                        <tr><td class="left">4x:</td><td id="lines_4" class="game-value">0</td></tr>
                        <tr><td class="left">3x:</td><td id="lines_3" class="game-value">0 </td></tr>
                        <tr><td class="left">2x:</td><td id="lines_2" class="game-value">0</td></tr>
                        <tr><td class="left">1x:</td><td id="lines_1" class="game-value">0</td></tr>
                    </tbody></table>
                </div>
                <div class="infoline next black" onclick="game.handle_event({class:'button', key:'hold' });">
                    Hold:<br/><span id="mem-piece"></span>
                </div>
                <div class="infoline">
                    <div class="button" onclick="game.handle_event({class:'button', key:'hold' });">Hold</div><br/>
                    <div class="button" onclick="game.handle_event({class:'button', key:'pause' });">Pause</div><br/>
                </div>
            </div>
            <div id="board" data-screen="play" class="black"></div>
        </div>
        <div class="container">
            <h1>Block game</h1>
            <p>This is a free time hobby project for myself. I was tired of ads in Tetris
                games and decided to make my own minimalistic game.</p>
            <p>This game is implemented entirely with JavaScript and HTML without any
                additional libraries.</p>
        </div>
        <div class="container">
            <h2>Statistics</h2>
            <h3>Previous game</h3>
            <p>Here are the statistics from your previous game:</p>
            <table class="stats black">
                <colgroup><col/><col style="width:100px;"/></colgroup>
                <tbody>  
                    <tr><td>Time:</td><td id="previous-time" class="game-value"></td></tr>
                    <tr><td>Score:</td><td id="previous-score" class="game-value"></td></tr>
                    <tr><td>Level:</td><td id="previous-level" data-default="1" class="game-value"></td></tr>
                    <tr><td>4-line combos:</td><td id="previous-lines_4" class="game-value"></td></tr>
                    <tr><td>3-line combos:</td><td id="previous-lines_3" class="game-value"></td></tr>
                    <tr><td>2-line combos:</td><td id="previous-lines_2" class="game-value"></td></tr>
                    <tr><td>Single lines:</td><td id="previous-lines_1" class="game-value"></td></tr>
                    <tr><td>Lines:</td><td id="previous-lines" class="game-value"></td></tr>
                </tbody>
            </table>
        </div>
        <div class="container">
            <h3>Overall statistics</h2>
            <p>Here are your overall statistics:</p>
            <table class="stats black">
                <colgroup><col/><col style="width:100px;"/></colgroup>
                <tbody>  
                    <tr><td>Games played:</td><td id="ot-games"></td></tr>
                    <tr><td>First game played:</td><td id="ot-first_game"></td></tr>
                    <tr><td>Time spend:</td><td id="ot-time"></td></tr>
                    <tr><td>Best score:</td><td id="ot-score"></td></tr>
                    <tr><td>Highest level:</td><td id="ot-level"></td></tr>
                    <tr><td>Average 4 row clears:</td><td id="ot-lines_4"></td></tr>
                </tbody>    
            </table>
        </div>
        <div id="footer">
            2023 &copy; <a href="https://github.com/tkoivula/">T. Koivula</a> <a href="https://github.com/tkoivula/tkoivula.github.io/">[Source code]</a>
        </div>
    </body>
</html>