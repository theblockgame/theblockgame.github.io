<!DOCTYPE html>
<html>
    <head>
        <meta charset = "utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title> Block game </title>
        <script type = "text/javascript">
const [ board_width, board_height ] = [ 10, 20 ];
const block_size = 22;
const block_space = 2;
const block_size_spaced = block_size + block_space;
const piece_size = 5 * block_size_spaced;
const margin_y = margin_x = 5;
const block_types = [
    { id: "T", shape: [ [-1, -1], [0, -1], [1, -1], [0, 0] ] },
    { id: "I", shape: [ [-1, -1], [0, -1], [1, -1], [2, -1] ] },
    { id: "S", shape: [ [-1, 0], [0, 0], [0, -1], [1, -1] ] },
    { id: "Z", shape: [ [-1, -1], [0, -1], [0, 0], [1, 0] ] },
    { id: "O", shape: [ [-1, -1], [0, -1], [-1, 0], [0, 0] ] },
    { id: "L", shape: [ [-1, 0], [0, 0], [1, 0], [1, -1] ] },
    { id :"J", shape: [ [-1, -1], [-1, 0], [0, 0], [1, 0] ] }
];
const action_keys = { p: 80, space: 32, left: 37, right: 39, up: 38, down: 40, s: 83, w: 87, h: 72, q: 81, r: 82  }
const debug = true;
const refresh_rate = 1000 / 30; // 30 FPS
const game_modes = {
    standard: { game_time: 0, title: "Standard Game", desc: "No time limit" },
    quick: { game_time: 1000 * 60 * 3, title: "Quick Game", desc: "Best in 3 mins" }
}

const game = {
    state: null,
    states: null,
    current_screen: null,
    next_piece: null,
    hold_piece: null,
    current_piece: null,
    is_new_personal_best: null,
    main_loop_timer: null,
    
    init: function() {
        game.states = { menu: {}, not_started: {}, play: {}, paused: {}, game_over: {} };
        for (const [id, state] of Object.entries(game.states)) state.id = id;
        game.states.play.handlers = [
            { filter: (e) => [action_keys.p, "pause"].includes(e.key), screen: "pause", action: game.pause, state: game.states.paused },
            { filter: (e) => e.key === action_keys.space || e.direction === "swipe_down", action: game.drop },
            { filter: (e) => e.key === action_keys.left, action: function(e) { game.move_left_or_right(-1) }},
            { filter: (e) => e.key === action_keys.right, action: function(e) { game.move_left_or_right(1) }},
            { filter: (e) => e.direction === "move", action: function(e) { game.move_left_or_right(e.value); } },
            { filter: (e) => e.key === action_keys.up || e.direction === "point", action: game.rotate_cw },
            { filter: (e) => e.key === action_keys.down, action: game.rotate_ccw },
            { filter: (e) => [action_keys.h, "hold"].includes(e.key), action: game.switch_hold_piece }
        ];
        if (debug) {
            game.states.play.handlers.push(
                { filter: (e) => { return e.key === action_keys.w; }, action: () => inc("level", 1) });
            game.states.play.handlers.push(
                { filter: (e) => { return e.key === action_keys.s; }, action: () => inc("level", -1) });
        }
        game.states.menu.handlers = [
            { filter: (e) => [action_keys.s, "new_game"].includes(e.key), screen: "play", action: function() { game.restart_new_game("standard"); } },
            { filter: (e) => [action_keys.q, "new_quick_game"].includes(e.key), screen: "play", action: function() { game.restart_new_game("quick"); } }
        ];
        game.states.paused.handlers = [
            ...game.states.menu.handlers,
            { filter: (e) => [action_keys.p, action_keys.r, "resume"].includes(e.key), screen: "play", action: game.resume, state: game.states.play }
        ];
        game.state = game.states.menu;
        msg.log("Initial game state is ", game.state.id);
        this.switch_to_screen("menu");
    },

    switch_to_screen: function(screen) {
        for (const elem of document.querySelectorAll('[data-screen]')) {
            if (elem.id === "board") continue; // never hide board
            elem.style.visibility = elem.dataset.screen === screen ? "visible" : "hidden";
        }
        this.current_screen = msg.log("Switching to screen ", screen);
    },

    handle_event: function(event) {
        const handlers = game.state.handlers;
        if (game.state.handlers) for (const h of game.state.handlers) {
            if (h.filter(event)) {
                if (h.screen) game.switch_to_screen(h.screen);
                if (h.action) h.action(event);
                if (h.state) {
                    msg.log("Entering state ", h.state.id);
                    game.state = h.state;
                }
                return;
            }
        }
        msg.log("State is ", game.state.id);
        msg.log_json("WARN! None of the handlers matched for ", event);
    },

    start_game: function(game_mode) {
        document.getElementById("main").dataset.game_mode = game_mode;
        document.getElementById("main").dataset.game_time = game_modes[game_mode].game_time;        
        msg.refresh_time();
        board.init();
        game.clear_hold_piece();
        if (game_modes[game_mode].desc) msg.send([game_modes[game_mode].desc], "", 1000);
        msg.send(["3", "2", "1"], "", 500);
        msg.send(["Play!"], "", 1000, () => {
            msg.log("New game");
            score_board.clear_current_stats(game_mode);
            this.resume();
            game.is_new_personal_best = false;
            game.next_piece = { geometry: { ...block_types[Math.floor(Math.random() * block_types.length)] } };
            game.next_piece.geometry.original_shape = [...game.next_piece.geometry.shape]; 
            game.create_new_piece();
            game.state = game.states.play;
            game.main_loop_timer = window.setInterval(game.main_loop, refresh_rate);
        }); 
    },

    restart_new_game: function(game_mode) {
        if (!game_mode) game_mode = document.getElementById("main").dataset.game_mode; // same as last game
        game.state = game.states.not_started;
        window.clearInterval(game.main_loop_timer); game.main_loop_timer = null;
        msg.timer_clear();
        msg.clear_messages();
        game.start_game(game_mode);
    },

    pause: function() { msg.timer_off(); },

    resume: function() {
        msg.timer_on();
        const remaining_time = msg.refresh_time();
        if (remaining_time > 0) msg.schedule_count_down(remaining_time, [120, 60, 10, 3, 2, 1], game.timeout);
        msg.log("Resume.");
    },

    switch_hold_piece: function() {
        if (game.hold_piece) {
            if (board.overlap(game.hold_piece.geometry.shape, game.current_piece.screen_x, game.current_piece.screen_y)) return; // no space
            if (game.current_piece.shadow) piece.remove_shadow(game.current_piece.shadow);
            [ game.current_piece.geometry, game.hold_piece.geometry ] = [ game.hold_piece.geometry, game.current_piece.geometry ];
            piece.create_shadow(game.current_piece);
            piece.draw_blocks(game.current_piece, game.current_piece.div);
        } else {
            if (game.current_piece.shadow) piece.remove_shadow(game.current_piece.shadow);
            game.current_piece.div.parentNode.removeChild(game.current_piece.div);
            game.hold_piece = { ...game.current_piece };
            game.create_new_piece();
        }
        game.hold_piece.geometry.shape = game.hold_piece.geometry.original_shape; // reset orientation
        piece.draw_blocks(game.hold_piece, document.getElementById("hold-piece"), false, 0, 0, 0.75);
    },

    clear_hold_piece: function() {
        if (game.hold_piece) {
            const div = document.getElementById("hold-piece");
            while (div.lastElementChild) div.removeChild(div.lastElementChild);
            game.hold_piece = null;
        }
    },

    create_new_piece: function() {
        const [x,y] = [((board_width / 2) - 3) * block_size_spaced, -1 * block_size_spaced];
        this.current_piece = piece.create_new(this.next_piece.geometry, x, y);
        // create new next piece:
        this.next_piece = { geometry: { ...block_types[Math.floor(Math.random() * block_types.length)] } };
        this.next_piece.geometry.original_shape = [...this.next_piece.geometry.shape]; 
        piece.draw_blocks(this.next_piece, document.getElementById("next-piece"), false, 0, 0, 0.75);
    },

    is_current_piece_in_valid_position: function() {
        const p = this.current_piece;
        return !board.overlap(p.geometry.shape, p.screen_x, p.screen_y);
    },

    game_over: function() {
        msg.timer_off();
        window.clearInterval(this.main_loop_timer); this.main_loop_timer = null;
        this.state = game.states.game_over;
        score_board.update_and_show_current_stats();
        msg.send(["Game Over!"], "", 2000, () => {
            game.state = game.states.menu;
            this.switch_to_screen("menu");
        });
    },

    timeout: function() {
        msg.send(["Timeout!"], "", 1000);
        game.game_over();
    },

    freeze_current_piece: function() {
        board.mark_position_to_board(game.current_piece.screen_x, game.current_piece.screen_y, game.current_piece, game.current_piece.div);
    },

    clear_full_lines: function(lines) {
        lines.forEach((l) => board.remove_line(l));
        board.animate_drop(this.current_piece, lines, 0, block_size_spaced, 4, refresh_rate);
    },

    move_left_or_right: (dx) => piece.move_left_or_right(game.current_piece, dx < 0 ? -1 : dx > 0 ? 1 : 0),
    move_left: () => piece.move_left_or_right(game.current_piece, -1), 
    move_right: () => piece.move_left_or_right(game.current_piece, 1), 
    drop: () => piece.drop(game.current_piece),
    rotate_cw: () => piece.rotate(game.current_piece, 1),
    rotate_ccw: () => piece.rotate(game.current_piece, -1),

    main_loop: function() {
        if (game.state != game.states.play) return;
        const blocked = !piece.move_down_at_most(game.current_piece, 0.3 * Number(get("level")));
        if (blocked) {
            game.state = game.states.play;
            game.freeze_current_piece();
            inc("score", (Number(get("level")) * game.current_piece.geometry.shape.length));
            game.create_new_piece();
            const lines = board.find_full_lines();
            if (lines.length > 0) {
                inc("score", Math.floor(Math.pow(2, lines.length - 1) * 100));
                inc("lines", lines.length);
                inc("lines_" + lines.length, 1);
                if (lines.length == 4) msg.send(["Nice, 4 rows!"], "", 1000);
                if (Number(get("lines")) / 10 > Number(get("level"))) {
                    inc("level", 1);
                    msg.send(["Level up!"], "", 1000)
                }
                game.clear_full_lines(lines);
            }
            if (Number(get("score")) > score_board.ot_stats.score) {
                if (!game.is_new_personal_best) {
                    if (score_board.ot_stats.score > 0) msg.send(["New personal best!"], "", 2000);
                    game.is_new_personal_best = true;
                }
            }
            if (!game.is_current_piece_in_valid_position()) game.game_over();
        }
    }
}

const msg = {
    queue: [],
    current_entry: null,
    timers: [],

    init: function() {
        window.setInterval(msg.draw_next_message, 100);
    },  

    send: function(messages, type, time, after_action) {
        for (var i = 0; i < messages.length - 1; ++i) {
            this.queue.push({ message: messages[i], type, time });
        }
        const last_entry = { message: messages[i], type, time, after_action };
        msg.queue.push(last_entry);
        return last_entry;
    },

    draw_next_message: function() {
        if (msg.queue.length == 0 || msg.current_entry) return;
        msg.current_entry = msg.queue.shift();
        const div = document.getElementById("message-area");
        div.className = "message " + msg.current_entry.type;
        div.style.visibility = "visible";
        div.innerText = msg.current_entry.message;
        if (msg.current_entry.time !== 0) setTimeout(msg.clear_message, msg.current_entry.time);
    },

    clear_message: function() {
        const entry = msg.current_entry;
        msg.current_entry = null;  
        if (entry && entry.after_action) entry.after_action();
        const div = document.getElementById("message-area");
        div.style.visibility = "hidden";
        div.innerText = "";
    },

    clear_messages: function() {
        msg.queue = [];
        msg.clear_message();
    },

    timer_on: function() {
        msg.log("Timer on");
        if (document.getElementById("main").dataset.start_time) return; // already running?!?
        document.getElementById("main").dataset.start_time = Date.now();
        this.timers.push(window.setInterval(msg.refresh_time, 1000));
    },

    timer_off: function() {
        while (this.timers.length > 0) window.clearInterval(this.timers.pop());
        const ds = document.getElementById("main").dataset;
        if (!ds.start_time) return; // not running?!?
        if (!ds.elapsed_time) ds.elapsed_time = 0;
        ds.elapsed_time = Number(ds.elapsed_time) + Date.now() - Number(ds.start_time);
        ds.start_time = "";
        msg.log("Timer off");
    },

    timer_clear: function() {
        const ds = document.getElementById("main").dataset;
        ds.elapsed_time = ds.start_time = ds.game_time = "";
    },

    refresh_time: function() {
        const ds = document.getElementById("main").dataset;
        var total = ds.elapsed_time ? Number(ds.elapsed_time) : 0;
        if (ds.start_time) total = total + (Date.now() - Number(ds.start_time));
        var remaining = Number(ds.game_time) - total; 
        set("time", total);
        if (ds.game_time && Number(ds.game_time) > 0) {
            set("remaining", remaining);
        }
        return remaining;
    },

    schedule_count_down: function(remaining, count_downs, action) {
        for (const t of count_downs) {
            if (t * 1000 > remaining) continue;
            this.timers.push(window.setTimeout(() => msg.send([format(t * 1000, "duration") + " left"], "", 900), remaining - (t * 1000) - 1000));
        }
        this.timers.push(window.setTimeout(action, remaining));
    },

    log: debug ? (msg, v = "") => { console.log(msg + v); return v; } : (msg, v) => v,
    log_json: debug ? (msg, json) => { console.log(msg + JSON.stringify(json)); return json; } : (msg, json) => json
}

const score_board = {
    local_store_object_id: "stats-6",
    ot_stats: null,

    init: function() {
        const str = localStorage.getItem(this.local_store_object_id);
        this.ot_stats = str ? JSON.parse(str) : {};
        this.show_overall_stats();
    },

    clear_current_stats: function(game_mode) {
        if (this.ot_stats[game_mode] &&  this.ot_stats[game_mode].score) set("best", this.ot_stats[game_mode].score);
        for (elem of document.getElementsByClassName("data-value")) {
            set(elem.id, elem.dataset.default ? elem.dataset.default : 0);
        }
    },

    update_and_show_current_stats: function(stats = {}) {
        stats.game_mode = document.getElementById("main").dataset.game_mode;
        for (elem of document.getElementsByClassName("data-value")) {
            stats[elem.id] = elem.dataset.value;
        }
        msg.log_json("Stats ", stats);
        for (key of Object.keys(stats)) set("previous-" + key, stats[key]); // show current
        score_board.update_overall_stats(stats); // show overall
    },

    update_overall_stats: function(stats) {
        if (!this.ot_stats[stats.game_mode]) this.ot_stats[stats.game_mode] = {};
        const ot = this.ot_stats[stats.game_mode];
        ot.games = ot.games ? ot.games + 1 : 1;
        ot.time = ot.time ? ot.time + Number(stats.time) : Number(stats.time);
        if (!ot.score || Number(stats.score) > ot.score) ot.score = Number(stats.score);
        if (!ot.leve || Number(stats.level) > ot.level) ot.level = Number(stats.level);
        if (!ot.lines || Number(stats.lines) > ot.lines) ot.lines = Number(stats.lines);
        if (!ot.lines_4 || Number(stats.lines_4) > ot.lines_4) ot.lines_4 = Number(stats.lines_4);
        if (!ot.first_game) ot.first_game = Date.now();
        localStorage.setItem(this.local_store_object_id, JSON.stringify(this.ot_stats));
        this.show_overall_stats();
    },

    show_overall_stats: function() {
        const ot = msg.log_json("Overall stats: ", this.ot_stats );
        for (const mode of Object.keys(game_modes)) {
            if (!ot[mode]) continue;
            for (key of Object.keys(ot[mode])) set("ot-" + mode + "-" + key, ot[mode][key]);
        }        
    }
}

const board = {
    matrix: [],
    board_div: null,

    init: function() {
        this.board_div = document.getElementById("board");
        this.board_div.innerHTML = "";
        this.board_div.style.width = (block_size_spaced * board_width) + "px";
        this.board_div.style.height = (block_size_spaced * board_height) + "px";

        for (div of document.getElementsByClassName("board-size")) {
            div.style.top = this.board_div.offsetTop + "px";
            div.style.left = this.board_div.offsetLeft + "px";
            div.style.width = this.board_div.offsetWidth + "px";
            div.style.height = this.board_div.offsetHeight + "px";            
        }
        // 1 col outside left and 1 col outside right 
        for (var i = 0; i < board_width + 2; ++i) {
            this.matrix[i] = [];
            const val = (i == 0 || i == board_width + 1) ? 1 : 0;
            // 4 rows above screen and 1 below screen
            for (var j = 0; j < board_height + 3; ++j) {
                this.matrix[i][j] = val;
            }
            this.matrix[i][j] = 1; // bottom border
        }
    },

    find_full_lines: function() {
        var full_lines = [];
        for (var y = 4; y < this.matrix[0].length - 1; ++y) {
            var full = true;
            for (var x = 1; x < this.matrix.length - 1; ++x) {
                if (this.matrix[x][y] == 0) { full = false; break }
            }
            if (full) full_lines.push(y);
        }   
        return full_lines;
    },

    remove_line: function(y) {
        for (var x = 1; x < this.matrix.length - 1; ++x) {
            var block_div = this.matrix[x][y]; var parent_div = block_div.parentElement;
            parent_div.removeChild(block_div);
            if (!parent_div.lastElementChild)
                parent_div.parentElement.removeChild(msg.log("Cleaning up an empty div ", parent_div));
            this.matrix[x][y] = 0;
        }
    },

    drop_above: function(y) {
        for (var x = 1; x < this.matrix.length - 1; ++x) {
            for (var yy = y - 1; yy > 0; --yy) {
                var block2 = this.matrix[x][yy];
                this.matrix[x][yy + 1] = block2;
            }
        }
    },

    animate_drop: function(current_piece, lines, current, total, step, delay) {
        lines.forEach((y) => {
            for (var x = 1; x < this.matrix.length - 1; ++x) {
                for (var yy = y - 1; yy > 0; --yy) {
                    if (this.matrix[x][yy]) this.matrix[x][yy].style.top =  (this.matrix[x][yy].offsetTop + step) + "px";
                }
            }
            if (current_piece.shadow) current_piece.shadow.style.top = (current_piece.shadow.offsetTop + step) + "px";
        });
        current += step;
        if (current < total) {
            setTimeout(() => board.animate_drop(current_piece, lines, current, total, step, delay), delay);
        } else {
            lines.forEach((y) => board.drop_above(y));
            piece.draw_shadow(current_piece);
        }

    },

    position_in_matrix: function(x, y) {
        return [ Math.floor(x / block_size_spaced) + 1, Math.floor(y / block_size_spaced) + 4 ];
    },

    overlap: function(shape, screen_x, screen_y) {
        return this.overlap_grid(shape, this.position_in_matrix(screen_x, screen_y));
    },

    overlap_grid: function(shape, pos) {
        for (i = 0; i < shape.length; ++i) {
            const x = pos[0] + shape[i][0] + 2;
            const y = pos[1] + shape[i][1] + 2;
            if (x < 0 || x >= this.matrix.length || y < 0 || y >= this.matrix[x].length) continue; 
            if (this.matrix[x][y] != 0) return true;
        }
        return false;
    },

    mark_position_to_board: function(screen_x, screen_y, current_piece, piece_div) {
        const position = this.position_in_matrix(screen_x, screen_y);
        for (i = 0; i < current_piece.geometry.shape.length; ++i) {
            const x = position[0] + current_piece.geometry.shape[i][0] + 2;
            const y = position[1] + current_piece.geometry.shape[i][1] + 2;
            this.matrix[x][y] = piece_div.children[i];
        }
    }
}

const piece = {

    create_new: function(geometry, x, y) {
        const piece = { geometry, screen_x: x, screen_y: y };
        piece.div = document.createElement( "div" );
        piece.div.className = "piece";
        piece.div.style.width = piece_size + "px";
        piece.div.style.height = piece_size + "px";
        // prevent overlapping on screen in case half of the piece would be visible
        const has_room = !board.overlap(piece.geometry.shape, piece.screen_x, piece.screen_y - 1)
        if (has_room) {
            document.getElementById("board").appendChild( piece.div );
            piece.shadow = this.create_shadow(piece);
            this.draw_blocks(piece, piece.div);
            this.move_and_draw(piece, 0, 0);
        }
        return piece;
    },

    draw_blocks: function(piece, div, draw_shadow = true, left = 0, top = 0, scale = 1.0) {
        while (div.lastElementChild) div.removeChild(div.lastElementChild);
        const piece_s = Math.floor(scale * piece_size);
        const block_s = Math.floor(scale * block_size);
        const block_spaced = Math.floor(scale * block_size_spaced);
        piece.geometry.shape.forEach(b => {
            const block = document.createElement("div");
            block.className = "block " + piece.geometry.id;
            block.style.width = block_s + "px";
            block.style.height = block_s + "px";
            block.style.left = (((piece_s / 2) - (block_spaced / 2) + (block_spaced * b[0])) + left) + "px";
            block.style.top = (((piece_s / 2) - (block_spaced / 2) + (block_spaced * b[1])) + top) + "px";
            div.appendChild(block);
        });
        if (draw_shadow && piece.shadow) this.draw_shadow(piece);
    },

    can_rotate: function(piece, rotated_shape) {
        const pos = board.position_in_matrix(piece.screen_x, piece.screen_y);
        // try first on current pos, then 1 right, 1 left, ..., 3 right, 3 left
        for (const movement of [ 0, 1, -1, 2, -2, 3, -3 ]) {
            if (this.can_move(piece, movement * block_size_spaced, 0) &&
                !board.overlap_grid(rotated_shape, [pos[0] +  movement, pos[1]])) {
                    return { with_movement: movement * block_size_spaced };
            }
        }
        return false;
    },

    rotate: function(piece, direction) {
        const rotated = piece.geometry.shape.map(b => direction == -1 ? [b[1], -1 * b[0]] : [-1 * b[1], b[0]]);
        const can_rotate = this.can_rotate(piece, rotated);
        if (can_rotate) {
            if (can_rotate.with_movement) this.move_and_draw(piece, can_rotate.with_movement, 0);
            piece.geometry.shape = rotated;
            this.draw_blocks(piece, piece.div);
        }
    },

    can_move: function(piece, dx, dy) {
        const pos = board.position_in_matrix(piece.screen_x, piece.screen_y);
        const new_pos = board.position_in_matrix(piece.screen_x + dx, piece.screen_y + dy);
        const dir = [dx == 0 ? 0 : dx / Math.abs(dx), dy == 0 ? 0 : dy / Math.abs(dy)];
        while (new_pos[0] != pos[0] || new_pos[1] != pos[1]) {
            pos[0] += dir[0]; pos[1] += dir[1];
            if (board.overlap_grid(piece.geometry.shape, pos)) return false;
        }
        return true;
    },

    move_and_draw: function(piece, dx, dy) {
        piece.screen_x += dx;
        piece.screen_y += dy;
        piece.div.style.top = Math.floor(board.board_div.offsetTop + piece.screen_y + margin_y) + "px";
        piece.div.style.left = (board.board_div.offsetLeft + piece.screen_x + margin_x) + "px";
        if (dx != 0 && piece.shadow) this.draw_shadow(piece);
    },

    move_left_or_right: function(piece, dx) {
        if (this.can_move(piece, dx * block_size_spaced, 0)) {
            this.move_and_draw(piece, dx * block_size_spaced, 0);
        }
    },

    move_down_at_most: function(piece, dy) {
        if (this.can_move(piece, 0, dy)) {
            this.move_and_draw(piece, 0, dy);
            return true;
        } else {
            // try with remaining portion
            dy = block_size_spaced - ((piece.screen_y + (4 * block_size_spaced)) % block_size_spaced) - 1;
            if (dy < 1) { this.remove_shadow(piece.shadow); return false; }
            if (this.can_move(piece, 0, dy)) {
                this.move_and_draw(piece, 0, dy);
                return true;
            }
        }
        this.remove_shadow(piece.shadow);
        return false;
    },

    create_shadow: function(piece) {
        piece.shadow = document.createElement( "div");
        piece.shadow.className = "piece shadow";
        piece.shadow.style.width = piece_size + "px";
        piece.shadow.style.height = piece_size + "px";
        document.getElementById("board").appendChild( piece.shadow );
        return piece.shadow;
    },

    draw_shadow: function(piece) {
        var dy = block_size_spaced; var step = block_size_spaced;
        while (true) {
            if (board.overlap(piece.geometry.shape, piece.screen_x, piece.screen_y + dy)) {
                dy -= step;
                step = step / 2;
                if (step <= 1) break;
            }
            dy += step;
        }
        //if (dy < (2 * block_size_spaced)) { this.remove_shadow(piece.shadow); return; } // too close
        piece.shadow.style.top = Math.floor(board.board_div.offsetTop + piece.screen_y + margin_y + dy) + "px";
        piece.shadow.style.left = (board.board_div.offsetLeft + piece.screen_x + margin_x) + "px";
        this.draw_blocks(piece, piece.shadow, false);
    },

    remove_shadow: function(shadow_div) {
        if (!shadow_div || !shadow_div.parentElement) return;
        shadow_div.parentElement.removeChild(shadow_div);
    },

    drop: function(piece) { while (this.move_down_at_most(piece, block_size_spaced)) {} }
}

const swipe_limit = 20;

const gestures = {
    start_x: null,
    start_y: null,
    event_sent: false,

    init: function() {
        const touch_div = document.getElementById("touch-area");
        touch_div.addEventListener('touchstart', gestures.touch_start, { passive: false });
        touch_div.addEventListener('touchmove', gestures.touch_move, { passive: false });
        touch_div.addEventListener('touchend', gestures.touch_end, { passive: false });
    },

    touch_start: function(e) {
        const { touches } = e;
        if (touches && touches.length == 1) {
            [ gestures.start_x, gestures.start_y ] = [ touches[0].clientX, touches[0].clientY ];
            gestures.event_sent = false;
            e.preventDefault();
        }
    },

    touch_move: function(e) {
        const [x,y] = [e.touches[0].clientX, e.touches[0].clientY];
        if (!gestures.event_sent && gestures.start_y < y - swipe_limit) {
            game.handle_event({ class: "touch", direction: "swipe_down" });
            gestures.start_y = y; gestures.event_sent = true;
            e.preventDefault();
        }
        else if (Math.abs(x - gestures.start_x) > swipe_limit) { 
            game.handle_event({ class: "touch", direction: "move", value: x - gestures.start_x });
            gestures.start_x = x; gestures.event_sent = true;
            e.preventDefault();
        }
    },

    touch_end: function(e) {
        if (!gestures.event_sent) {
            game.handle_event({ class:"touch", direction:"point"});
            e.preventDefault();
        }
    }
}

// helpers to access values shown on page
const set = function(id, value) {
    const elem = document.getElementById(id); if (!elem) return;
    elem.dataset.value = value;
    elem.innerText = elem.dataset.format ? format(value, elem.dataset.format) : value;
}

const format = function(value, format) {
    try {
        if (format === "duration") return new Date(value).toISOString().substr(11, 8).replace(/^[0]+[0:]/, "");
        if (format === "days") return Math.floor((Date.now() - value) / 1000 / 60 / 60 / 24) + " days ago";
    } catch (err) { console.log("Error converting value " + value + " to format " + format + ": " + err); } 
    return value;
}
const set_all = function(cl, value) {
    for (const elem of document.getElementsByClassName(cl)) { elem.innerText = value; }
}
const inc = function(id, value) { set(id, Number(get(id)) + value); }
const get = function(id) { return document.getElementById(id) ? document.getElementById(id).dataset.value : null; }

const buttons_init = function() {
    for (mode of Object.keys(game_modes)) {
        set_all(mode + "_title", game_modes[mode].title);
        set_all(mode + "_desc", game_modes[mode].desc);
    }
    for (const b of document.getElementsByClassName("button")) {
        b.onclick = () => game.handle_event({class:'button', key: b.id });
        if (b.dataset.key) b.innerHTML = b.innerHTML.replace(b.dataset.key,"<span class='key'>"+ b.dataset.key + "</span>");
    }
}

const keyboard_init = function() {
    const press = function(pressed) {
        //msg.log("Key press ", pressed.keyCode);
        if (Object.values(action_keys).indexOf(pressed.keyCode) < 0) return;
        pressed.preventDefault();
        game.handle_event({ class: "key_press", key: pressed.keyCode });
    }
    document.addEventListener( "keydown", press, false );
}

const init_page = function() {
    score_board.init();
    game.init();
    board.init();
    msg.init();
    keyboard_init();
    gestures.init();
    buttons_init();
}
        </script>
        <style>
body {
    margin: 0;
    background-color: rgb(88, 88, 88);
    font-family: 'Courier New', Courier, monospace;
    font-size: small;
}
#main {
    max-width: 1024px;
    min-height: 90vh;
    background-color: rgb(153, 157, 144);
    font-family: 'Courier New', Courier, monospace;
    font-size: small;
    padding-bottom: 50px;
}
a {
    text-decoration: none;
    color:white;
}
a:hover { color: brown; }
.stats {
    padding: 10px;
    margin-left: 20px;
}
.text-pane {
    padding: 10px 3% 10px 3%;
    max-width: 400px;
    display: inline-table;
}
.chapter { padding: 10px; }
#header {
    background-color: grey;
    text-align: right;
    color: white;
    padding: 5px;
}
#footer {
    max-width: 1024px;
    background-color: rgb(106, 112, 94);
    text-align: center;
    color: white;
    margin: 0px 0px 0px 0px;
    padding: 30px 0px 10% 0px;
}
#board {
    margin: 5px 0px 0px 0px;
    padding: 5px;
    text-align: center;
    float: left;
}
.score-board {
    padding: 0px 4px 4px 4px;
    text-align: center;
    float: left;
}
.score-board-vertical {
    width: 95%;
    padding: 4px 4px 0px 4px;
}
.score-board-vertical .score-box { float: left; }
.score-table .left { text-align: right; }
.score-table-right { width: 20px; }
.score-box {
    width: 80px;
    float: initial;
    margin: 4px;
    padding: 4px;
    border-radius: 2px;
}
.wide { width: 140px; }
.score-box-piece { height: 90px; }
.score-box-piece .piece { left: 0px; }
.piece {
    z-index: 50;
    background-color: transparent;
    position: absolute;
}
.T { background-color: purple; }
.I { background-color: cyan; }
.O { background-color: yellow; }
.S { background-color: green; }
.Z { background-color: red; }
.L { background-color: brown; }
.J { background-color: blue; }
.shadow { z-index: 10; }
.shadow .block { 
    background-color: rgb(40, 40, 40); 
    border: 1px dashed rgb(173, 175, 143);
}
.block { 
    position: absolute; 
    border-radius: 2px;
}
.button {
    border-radius: 4px;
    margin: 10px 15px 10px 15px;
    padding: 5px 10px 5px 5px;
    background-color: green;
    border: 2px solid darkgreen;
    color: white;
}
.button:active { background-color: darkgreen; }
.key { text-decoration: underline; }
#message-area {
    z-index: 97;
    visibility: hidden;
    background-color: transparent;
    color: white;
    font-weight: bolder;
    font-size: larger;
    position: absolute;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
}
#touch-area {
    z-index: 98;
    background-color: transparent;
    position: absolute;
}
.menu {
    z-index: 99;
    position: absolute;
    background-color: rgba(40, 40, 40, 0.7);
    top: 100px;
    vertical-align: center;
    text-align: center;
    width: 300px;
    height: 300px;
    color: white;
}
.menu .title { margin: 50px 10px 50px 10px; }
.menu .button { margin: 10px 30px 10px 30px; }
.black { 
    background-color: rgb(40, 40, 40); 
    color: white;
}
#version {
    font-size: x-small;
    margin-top: 20px;
    vertical-align: bottom;
}
        </style>
    </head>
    <body onload="init_page()">
        <div id="main">
            <div id="menu-div" data-screen="menu" class="menu board-size">
                <div class="title">Choose game mode:</div>
                <button id="new_game" class="button" data-key="S">New <span class="standard_title"></span></button>
                <div class="standard_desc"></div><br/><br/>
                <button id="new_quick_game" class="button" data-key="Q">New <span class="quick_title"></span></button>
                <div class="quick_desc"></div>
            </div>
            <div id="pause-div" data-screen="pause" class="menu board-size">
                <div class="title">Paused</div>
                <button id="resume" class="button" data-key="R">Resume</button><br/><br/><br/>
                <button id="new_game" class="button" data-key="S">New <span class="standard_title"></span></button>
                <div class="standard_desc"></div><br/><br/>
                <button id="new_quick_game" class="button" data-key="Q">New <span class="quick_title"></span></button>
                <div class="quick_desc"></div>
            </div>
            <div id="touch-area" class="board-size"></div>
            <div id="message-area" class="message black board-size"></div>
            <div class="score-board score-board-vertical">
                <div class="score-box black">Score:<br/> <span id="score" class="data-value">0</span></div>
                <div class="score-box black wide">Time:<br/>
                    <span id="time" data-format="duration" class="data-value">00:00</span>
                    (<span id="remaining" data-format="duration" class="data-value"></span>)
                </div>
                <div class="score-box black right">Best:<br/> <span id="best">see below</span></div>
            </div>
            <div class="score-board">
                <div class="score-box black">Level:<br/> <span id="level" data-default="1" class="data-value">0</span></div>
                <div class="score-box score-box-piece black" onclick="game.handle_event({class:'button', key:'hold' });">
                    Hold:<div id="hold-piece" class="piece"></div>
                </div>
                <div class="score-box black">
                    <table class="score-table"><tbody>  
                        <tr><td>Lines:</td> <td id="lines" class="data-value">0</td></tr>
                        <tr><td class="left">4x:</td><td id="lines_4" class="data-value">0</td></tr>
                        <tr><td class="left">3x:</td><td id="lines_3" class="data-value">0 </td></tr>
                        <tr><td class="left">2x:</td><td id="lines_2" class="data-value">0</td></tr>
                        <tr><td class="left">1x:</td><td id="lines_1" class="data-value">0</td></tr>
                    </tbody></table>
                </div>
                <div class="score-box score-box-piece black">Next piece:<div id="next-piece" class="piece"></div></div>
                <div class="score-box">
                    <button id="hold" class="button" data-key="H">Hold</button><br/>
                    <button id="pause" class="button" data-key="P">Pause</button><br/>
                    <div id="version">v. 0.2.1</div>
                </div>
            </div>
            <div id="board" data-screen="play" class="black"></div>
        <div class="text-pane">
            <div class="chapter">
                <h1>Block game</h1>
                <p>This is a free time hobby project for myself. I was tired of ads in Tetris
                    games and decided to make my own minimalistic game.</p>
                <p>This game is implemented entirely with JavaScript and HTML without any
                    additional libraries.</p>
            </div>
            <div class="chapter">
                <h2>Statistics</h2>
                <h3>Previous game</h3>
                <p>Here are the statistics from your previous game:</p>
                <table class="stats black">
                    <colgroup><col/><col style="width:100px;"/></colgroup>
                    <tbody>  
                        <tr><td>Time:</td><td id="previous-time" class="data-value" data-format="duration"></td></tr>
                        <tr><td>Score:</td><td id="previous-score" class="data-value"></td></tr>
                        <tr><td>Level:</td><td id="previous-level" data-default="1" class="data-value"></td></tr>
                        <tr><td>4-line combos:</td><td id="previous-lines_4" class="data-value"></td></tr>
                        <tr><td>3-line combos:</td><td id="previous-lines_3" class="data-value"></td></tr>
                        <tr><td>2-line combos:</td><td id="previous-lines_2" class="data-value"></td></tr>
                        <tr><td>Single lines:</td><td id="previous-lines_1" class="data-value"></td></tr>
                        <tr><td>Lines:</td><td id="previous-lines" class="data-value"></td></tr>
                    </tbody>
                </table>
            </div>
            <div class="chapter">
                <h3>Overall statistics</h2>
                <p>Here are your overall statistics:</p>
                <table class="stats black">
                    <colgroup><col/><col style="width:100px;"/><col style="width:100px;"/></colgroup>
                    <tbody>  
                        <tr>
                            <td>Games played:</td>
                            <td id="ot-standard-games" class="data-value"></td>
                            <td id="ot-quick-games" class="data-value"></td>
                        </tr>
                        <tr>
                            <td>First game played:</td>
                            <td id="ot-standard-first_game" class="data-value" data-format="days"></td>
                            <td id="ot-quick-first_game" class="data-value" data-format="days"></td>
                        </tr>
                        <tr>
                            <td>Time spend:</td>
                            <td id="ot-standard-time" class="data-value" data-format="duration"></td>
                            <td id="ot-quick-time" class="data-value" data-format="duration"></td>
                        </tr>
                        <tr>
                            <td>Best score:</td>
                            <td id="ot-standard-score" class="data-value"></td>
                            <td id="ot-quick-score" class="data-value"></td>
                        </tr>
                        <tr>
                            <td>Highest level:</td>
                            <td id="ot-standard-level" class="data-value"></td>
                            <td id="ot-quick-level" class="data-value"></td>
                        </tr>
                        <tr>
                            <td>Max row clears:</td>
                            <td id="ot-standard-lines" class="data-value"></td>
                            <td id="ot-quick-lines" class="data-value"></td>
                        </tr>
                        <tr>
                            <td>Max 4-row combos:</td>
                            <td id="ot-standard-lines_4" class="data-value"></td>
                            <td id="ot-quick-lines_4" class="data-value"></td>
                        </tr>
                    </tbody>    
                </table>
            </div>
        </div>
    </div>

        <div id="footer">
            2023 &copy; <a href="https://github.com/tkoivula/">T. Koivula</a> <a href="https://github.com/tkoivula/tkoivula.github.io/">[Source code]</a>
        </div>
    </body>
</html>